--protocol between app and signaling server
Mcc01 
DEFINITIONS IMPLICIT TAGS ::= 
BEGIN

Mcc01Message ::= CHOICE 
{
	--difference between rsp and ack:
	--ack only means peer has got the message, so there must be no error code in ack message
	--rsp is the message handling response, usually has error code or result in rsp message

	versionCheckReq   [APPLICATION 1] Mcc01VersionCheckReq,
		-- c -> s
	versionCheckRsp   [APPLICATION 2] Mcc01VersionCheckRsp,
		-- s -> c

	relayLoginReq   [APPLICATION 11] Mcc01RelayLoginReq,
		-- c -> s

	relayLoginRsp   [APPLICATION 12] Mcc01RelayLoginRsp,
		-- s -> c

	relayStatusReq   [APPLICATION 13] Mcc01RelayGeneral,
		-- c -> s
		--app may request relay status when app need. for example, when app start or switch to foreground
	relayStatusRsp   [APPLICATION 14] Mcc01RelayStatusRsp,
		-- s -> c

	--relayFirmwareUpdateReq   [APPLICATION 15] Mcc01RelayGeneral,
		-- c -> s
	--relayFirmwareUpdateRsp   [APPLICATION 16] Mcc01RelayFirmwareUpdateRsp,
		-- s -> c


		--@command for outbound call
	sessionInvite      [APPLICATION 21] Mcc01SessionInvite,
		-- c -> s

	sessionConfirm      [APPLICATION 22] Mcc01SessionConfirm,
		-- s -> c

	sessionRelease      [APPLICATION 23] Mcc01SessionGeneral,
		-- c -> s
		-- sending sessionRelease is not necessary, session in gass or relay will auto release when timeout
		-- sessionRelease is designed for pigw, which wish to release session ASAP when call end.

	--sessionTouch        [APPLICATION 14] Mcc01SessionGeneral,
		-- c -> s
		-- client should send sessionTouch once it detect network changed, thus sever will keep the changed network
		-- adress ASAP.
		-- client should send sessionTouch twice to prevent UDP packet lost

	menuReq            [APPLICATION 25] Mcc01MenuReq,
		-- c -> s

	menuRsp            [APPLICATION 26] Mcc01MenuRsp,
		-- s -> c

	callSetup          [APPLICATION 31] Mcc01CallSetup,    
		-- c -> s

	callTrying        [APPLICATION 32] Mcc01CallGeneral, 
		-- s -> c
		--server should send back callTrying when it get a callSetup if CallAlerting cannot send back immediately.
		--thus indicate client that callSetup has been got, and original node no need try to resend callSetup

	callBusy           [APPLICATION 33] Mcc01CallGeneral, 
		-- s -> c
		-- server should send callBusy every 10 second when all the operators in busy
		-- TODO callBusy return the number of waiting caller

	callAlerting       [APPLICATION 34]  Mcc01CallGeneral,    
		-- s -> c

	callAlertingAck    [APPLICATION 35]  Mcc01CallGeneral,
		-- c -> s

	callAnswer         [APPLICATION 36]  Mcc01CallGeneral, 
		-- s -> c

	callAnswerAck      [APPLICATION 37]  Mcc01CallGeneral,
		-- c -> s

	callRelease        [APPLICATION 38]  Mcc01CallRelease,    
		-- s <-> c

	callReleaseAck     [APPLICATION 39]  Mcc01CallGeneral,
		-- c <-> s

	callVerifyReq      [APPLICATION 40]  Mcc01CallGeneral,
		-- s -> c
		--server should start to send callVerifyReq once into ANSWERED state.
		--client should respond with callVerifyRsp if call is still active. if call is not exist, send callRelease.
		--callVerifyReq sent every 10 second.
		--if server doesn't get callVerifyRsp in 30 second, it should release the call.
		--if client doesn't get callVerifyReq in 30 second, it should release the call.
		--The reason using callVerify is that client or server may crash or disconnect suddenly.

	callVerifyRsp      [APPLICATION 41]  Mcc01CallGeneral,
		-- c -> s

	callSetAudioStreamReq       [APPLICATION 42]  Mcc01CallSetAudioStreamReq,
		-- c <-> s
		--when call in answered state, both APP and relay can start callSetAudioStreamReq.
		--But when in call setup, relay should begin callSetAudioStreamReq once it sent callAlerting or 
		--callAnswer(if callAlerting not sent). that is, using backward-negotiation.
		--
		--Q: Why relay begins callSetAudioStreamReq in call setup, not APP?
		--A: consider interconnect with protocol like SIP, if APP begins callSetAudioStreamReq upon receiving callAlerting,
		--   how relay sending out SIP invite which must including SDP? since relay must send out SIP invite before it can
		--   return callAlerting to APP.
		--   But if relay begin callSetAudioStreamReq, relay can firstly negotiate with SIP peer, and sending 
		--   callSetAudioStreamReq using the result of SIP SDP negotiation. This is why using backward-negotiation.
	callSetAudioStreamRsp    [APPLICATION 43]  Mcc01CallSetAudioStreamRsp,
		-- s <-> c

	callSetAudioCodecReq       [APPLICATION 44]  Mcc01CallSetAudioCodecReq,
		-- c <-> s
	callSetAudioCodecRsp    [APPLICATION 45]  Mcc01CallSetAudioCodecRsp,
		-- s <-> c
		--#command for outbound call 

		--@command for inbound call 

		--signaling sequence when callIn:
		--1, normal call:
		--  1), gmobile send pushkit when callIn, UUID set in push notification
		--  2), app got pushkit.
		--  3), app start callkit.
		--  4), app send callInAlerting in completion block in CXProvider reportNewIncomingCallWithUUID func. 
		--      (error is nil in completion block)
		--  5), gmobile send back callInAlertingAck.
		--  6), app send callInAnswer if user click Answer of callkit or
		--  7), app send callInRelease if user click Drop of callkit
		--2, call reject by APP
		--  1), gmobile send pushkit when callIn, UUID set in push notification
		--  2), app got pushkit. APP decide to reject the call.
		--  3), app send callInReject in completion block in CXProvider reportNewIncomingCallWithUUID func. 
		--      (error is set in completion block)
		--  4), gmobile send back callInRejectAck.
		--3, call has been released by calling party when gmobile get callInAlerting:
		--  1), gmobile send pushkit when callIn, UUID set in push notification
		--  2), app got pushkit.
		--  3), app start callkit.
		--  4), app send callInAlerting in completion block in CXProvider reportNewIncomingCallWithUUID func. 
		--      (error is nil in completion block)
		--  5), gmobile find call has been released by calling party. it firstly send back callInAlertingAck. then
		--  6), gmobile send callInRelease after sending callInAlertingAck.


	callInAlerting          [APPLICATION 54] Mcc01CallInGeneral,
		-- c -> s
	callInAlertingAck       [APPLICATION 55] Mcc01CallInGeneral,
		-- s -> c

	--callInReject          [APPLICATION 56] Mcc01CallInGeneral,
		-- c -> s
	--callInRejectAck       [APPLICATION 57] Mcc01CallInGeneral,
		-- s -> c

	--callInSetup          [APPLICATION 51] Mcc01CallInSetup,
		-- s -> c

	--callInTrying         [APPLICATION 52] Mcc01CallInGeneral, 
		-- c -> s

	--callInAlerting       [APPLICATION 54]  Mcc01CallInGeneral,    
		-- c -> s

	--callInAlertingAck    [APPLICATION 55]  Mcc01CallInGeneral,
		-- s -> c

	callInAnswer         [APPLICATION 58]  Mcc01CallInGeneral, 
		-- c -> s

	callInAnswerAck      [APPLICATION 59]  Mcc01CallInGeneral,
		-- s -> c

	callInRelease        [APPLICATION 60]  Mcc01CallInRelease,    
		-- s <-> c

	callInReleaseAck     [APPLICATION 61]  Mcc01CallInGeneral,
		-- c <-> s

	callInVerifyReq      [APPLICATION 62]  Mcc01CallInGeneral,
		-- s -> c
		--server should start to send callVerifyReq once into ANSWERED state.
		--client should respond with callVerifyRsp if call is still active. if call is not exist, send callRelease.
		--callVerifyReq sent every 10 second.
		--if server doesn't get callVerifyRsp in 30 second, it should release the call.
		--if client doesn't get callVerifyReq in 30 second, it should release the call.
		--The reason using callVerify is that client or server may crash or disconnect suddenly.

	callInVerifyRsp      [APPLICATION 63]  Mcc01CallInGeneral,
		-- c -> s

	callInSetAudioStreamReq       [APPLICATION 64]  Mcc01CallInSetAudioStreamReq,
		-- c <-> s
		--when callIn in answered state, both APP and relay can start callInSetAudioStreamReq.
		--But when in callIn setup, we decide relay begin callInSetAudioStreamReq once it got callInAnswer. 
		--that is, using backward-negotiation. thus may save network data flow as much as possible.
		--relay don't send callInSetAudioStreamReq when it got callInAlerting, thus save network data flow.
	callInSetAudioStreamRsp    [APPLICATION 65]  Mcc01CallInSetAudioStreamRsp,
		-- s <-> c

	callInSetAudioCodecReq       [APPLICATION 66]  Mcc01CallInSetAudioCodecReq,
		-- c <-> s
	callInSetAudioCodecRsp    [APPLICATION 67]  Mcc01CallInSetAudioCodecRsp,
		-- s <-> c
		--#command for inbound call

		--@command for message sending out
	messageNonceReq     [APPLICATION 71]  Mcc01MessageNonceReq,
		-- c -> s
	messageNonceRsp      [APPLICATION 72]  Mcc01MessageNonceRsp,
		-- s -> c
	messageSubmitReq      [APPLICATION 73]  Mcc01MessageSubmitReq,
		-- c -> s
	messageSubmitRsp      [APPLICATION 74]  Mcc01MessageSubmitRsp,
		-- s -> c
		--#command for message sending out
		--@command for message incoming
	messageInHello              [APPLICATION 77] Mcc01MessageInHello,
		-- c -> s
		-- APP should send hello ASAP when it got push notification
	messageInHelloAck             [APPLICATION 78] Mcc01MessageInHelloAck,
		-- s -> c
		-- client should know whether server have received hello
	messageDeliverReq      [APPLICATION 79]  Mcc01MessageDeliverReq,
		-- s -> c
	messageDeliverRsp      [APPLICATION 80]  Mcc01MessageDeliverRsp
		-- c -> s
		--#command for message incoming
}

Mcc01VersionCheckReq  ::= SEQUENCE
{
	myVersion       [1]    IA5String
}

Mcc01VersionCheckResult ::= ENUMERATED 
{   
	versionUpToDate(0),
	versionCanUpdate(1),
	versionMustUpdate(2)
}       

Mcc01VersionCheckRsp  ::= SEQUENCE
{
	result       [1]    Mcc01VersionCheckResult
}

Mcc01PhoneType ::= ENUMERATED 
{   
	iphone (1),
	android(2)
}       

Mcc01RelayLoginReq  ::= SEQUENCE
{
	seqId               [1]  INTEGER,
		--seqId is used to match req and rsp. 
		--seqId should not duplicate during APP running. normally +1 per each req
		--the reason using seqId is that each req authCode may be different, so if no seqId, authCode stored 
		--in APP and Server may be not same.
	relaySN             [2]  INTEGER(0..4294967295),
	relayName           [3]  OCTET STRING,
		--relay name is given by user, utf-8 format.
	phoneType           [4]  Mcc01PhoneType,
	pushToken           [5]  IA5String,
		--in IOS, pushToken is the device token return by Apple APNs to APP.
		--in Android, pushToken is RegistrationID in jiguang
	pushTokenVoIP       [6]  IA5String,
		--in IOS, pushTokenVoIP is the VoIP device token return by Apple push kit to APP, and MUST exist
		--in Android, pushTokenVoIP set same value as pushToken
	authCode            [7]  IA5String
		--authCode is a random number generated and stored in APP used for auth purpose in callSetup.
}

Mcc01RelayLoginErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError(1),
	invalidParmInReq (2),
	cardStillInsertedInRelay(3),
	relayNotOnline(4),
	otherError(99)
}       

Mcc01RelayLoginRsp  ::= SEQUENCE
{
	seqId               [1]  INTEGER,
		--same as req
	relaySN             [2]  INTEGER(0..4294967295),
		--same as req

	errorCode           [3]  Mcc01RelayLoginErrorCode OPTIONAL
		--errorCode must not set when no error
}

Mcc01RelayGeneral  ::= SEQUENCE
{
	relaySN             [1]  INTEGER(0..4294967295)
}

--Mcc01RelayFirmwareUpdateStatus ::= ENUMERATED 
--{   
--	noUpdate(0),
--	canUpdate(1),
		--firmware in relay is ready to update and user may select to update firmware
--	mustUpdate(2)
		--firmware in relay is ready to update and user MUST update firmware before continuing using APP.
--}       

Mcc01RelayStatusRsp  ::= SEQUENCE
{
	relaySN             [1]  INTEGER(0..4294967295),
		--same as req

	networkOK           [2]  BOOLEAN,
		--whether relay network is OK.

	signalStrength      [3]   INTEGER(0..5)
		--for gmobile, 0 means no mobile Signal, 5 means powerest mobile signal
		--for gstation, set to 0 when phone line disconnected, set to 5 when phone line connected

	--relayFirmwareUpdateStatus    [4] Mcc01RelayFirmwareUpdateStatus
}

--Mcc01RelayFirmwareUpdateResult ::= ENUMERATED 
--{   
--	updateStarted(0),
--	noFirmwareNeedToUpdate(1),
--	otherError(99)
--}       

--Mcc01RelayFirmwareUpdateRsp  ::= SEQUENCE
--{
--	relaySN             [1]  INTEGER(0..4294967295),
		--same as req

--	result           [2]  Mcc01RelayFirmwareUpdateResult
--}

--Mcc01SessionInvite is used to establish session
Mcc01SessionInvite  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
		--sessionId is a global parm, MUST be a random number to avoid sessionId conflict, must >0
		--relay should keep sessionId relevant data until timeout, for example, no message got in 1 hour for specified callId.

	mmTerminal         [2]   BOOLEAN,
		--whether terminal is a multimedia terminal, should set to false when terminal only support audio, such as call from PSTN
		--server will use mmTerminal to judge whether client support non-audio interaction.

	calledNumber        [5]   IA5String,
		--address string, like "95510" "4008201234"

	callingNumber       [6]   IA5String OPTIONAL,
	callingName         [7]   OCTET STRING (SIZE (1..512)) OPTIONAL,
		--UTF-8 encoded

	--TODO modify callingNumber and callingName to callingName and callingMSISDN

	userInfo            [11]   OCTET STRING OPTIONAL,
		--UTF-8 encoded

	myRelaySN             [15]  INTEGER OPTIONAL
		--this relaySN is configured in client and may be used for routing in gass
	--useMyRelayFirstly     [16]  NULL OPTIONAL
		--when exist, use myRelay first.
		--if both useMyRelayFirstly and myRelaySN exist, gass directly use myRelaySN.
		--else, gass firstly search called_number_relay_sn for relaySN, if not found,then use myRelaySN. 

	--TODO may add Geolocation info in message
}

Mcc01SessionErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	sessionIdConflict(2),
	sessionIdInvalid(3),
	noRouteForCalledNumber(4),
	relayNotOnLine(5),
	calledNumberInvalid(6), 
	callStillActiveInGmobile(7),
	--...
	previousCallNotIdle(90), --used by java
	sessionInitFailed(91), --used by java
	sessionInviteJNIFailed(92), --used by java
	sessionOverrided(93), --used by java
	sessionFindServerFailed(94), --used by java
	timeout(97), --used by java
	--noInit(98), 
	otherError(99)
}       

Mcc01SessionConfirm  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,

	relaySN             [2]  INTEGER(0..4294967295) OPTIONAL,
		--return relaySN to app, and app should set relaySN in the following message
		--gamt may use relaySN to do gass distrubtor
		--only and must exist when no error code

	menuSupport        [3]  BOOLEAN OPTIONAL,
		--whether support menu 

		--chatSupport and callSupport are global switchs.
		--if chatSupport or callSupport set to false,
		--client should not send chat or call relevant message even if next_action is chat or call or cnc.
		--
		--if chatSupport == true, client can start chat with menuLevel set to "-"
		--if callSupport == true, client can start call with menuLevel set to "-"
		--only and must exist when no error code

	chatSupport         [4]  BOOLEAN OPTIONAL,
		--whether support chat
		--only and must exist when no error code

	callSupport         [5]  BOOLEAN OPTIONAL,
		--whether support call
		--only and must exist when no error code

	nonce               [8]  IA5String OPTIONAL,
		--only exist when call need authentication
		--valid in this session
		--only exist when no error code
		--nonce is 8 bytes size
	

	errorCode           [13]  Mcc01SessionErrorCode OPTIONAL
		--errorCode must not set when no error
}

Mcc01SessionGeneral  ::= SEQUENCE
{
	sessionId              [1]   INTEGER
}

--an example of menu:  (use hanyu pinyin instead of Chinese character since we cannot use Chinese in this protocol)
--    menu_level    next_action       content
--    $1            none              Huanying boda Qunar kefu rexian
--    $2            none              Cong jiri qi, dinggou guonei jipiao quanmian 5 ze youhui
--    1             menu              zhongwen fuwu
--    2             menu              English service
--    11            menu              jipiao
--    12            menu              jiudian
--    21            menu              air ticket
--    22            menu              hotel
--    111           menu              guonei jipiao
--    112           chat              guoji jipiao
--    121           cnc               guonei jiudian
--    122           cnc               guoji jiudian
--    211           call              domestic air ticket
--    212           call              international air ticket
--    221           call              domestic hotel
--    222           call              internaltional hotel 
--    1111          cnc               guonei jipiao yuding
--    1112          cnc               guonei jipiao tuiding
--...

--menu_level normally relevant to IVR menu, use $x menu_level if no relevant IVR menu.
--If req with menu_level -, rsp will return menu $1&$2&1&2,
--If req with menu_level 1, rsp will return menu 11&12
--If req with menu_level 11, rsp will return menu 111&112
--If req with menu_level 111, rsp will return menu 1111&1112
--...
--The number of returning menus CAN NOT more than 16 on one menu request. so req_level should be carefully set to avoid this.
--
--So if a callSetup is sent with menu_level 1111, callcenter will know the customer want book demestic air ticket and He/She want
--Chinese service.
--menu_level digits usually correspond with digits in voice call menu.
--
--another example:
--    menu_level     next_action           content
--    $1             none                  Huanying boda Qunar kefu rexian
--    $2             none                  Cong jiri qi, dinggou guonei jipiao quanmian 5 ze youhui
--In this example, App should display content of $1 and $2, and provide no following service
--
--another example:
--    menu_level     next_action           content
--    $1             none                  Huanying boda Qunar kefu rexian
--    $2             none                  Cong jiri qi, dinggou guonei jipiao quanmian 5 ze youhui
--    $3             call                  rengong yuyin fuwu
--In this example, App should display content of $1 and $2 and $3, and start callSetup when user select $3.

Mcc01MenuReq  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	transId              [2]   INTEGER,
		--transId used to match menuReq and Rsp, may simply start from 1.

	relaySN             [3]  INTEGER(0..4294967295),
		--gamt may use relaySN to do gass distrubtor

	menuLevel            [13]   IA5String,
		--request certain menuLevel means get sub menu under this level, for example above:
		--if menuLevel == 1, then menu 11&12(also sub sub menu) should return.
		--
		--Attention:
		--naming menuLevel same as IVR menu is a good idea.
		--if set menuLevel to "-", means request entrance menu from server.

	userInputContent1          [14]  OCTET STRING  OPTIONAL,
		--userInputContent may encrypt using RSA.  
		--when using RSA, first byte set to 0xFFEE, following by real userInputContent.
		--Each call-center may generate their own RSA key pair, put private key in their Relay, and put public key in APP.
		--No, it's not a good idea to let each call-center have their own RSA key pair, otherwise, design a centralized APP
		--maybe a messy issue.
	userInputContent2          [15]  OCTET STRING  OPTIONAL,
	userInputContent3          [16]  OCTET STRING  OPTIONAL
}

Mcc01TransErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	sessionIdInvalid(3),  --session may timeout
	--menuNotSupport(4),
	--...
	menuReqJNIFailed(92), --used by java
	transOverrided(93), --used by java
	invalidMenuLevel(96),  --used by java
	timeOut(97),  --used by java
	noInit(98),  --used by java
	otherError(99)
}       

Mcc01MenuRsp  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,

	transId              [2]   INTEGER,
		--same as req
	menu                [12]   Mcc01Menu OPTIONAL,
		--menu on this menuLevel
	errorCode           [13]  Mcc01TransErrorCode OPTIONAL 
		--errorCode must not set when no error
}

Mcc01Menu  ::= SEQUENCE SIZE (0..16) OF Mcc01MenuItem

Mcc01NextAction ::= ENUMERATED 
{   
	none (0),
	menu (1),
	chat (2),
	call (3),
	cnc  (4),  --chat and call
	newSession(5)
}       

Mcc01MenuItem  ::= SEQUENCE 
{
	menuLevel       [1]         IA5String,
	contentType     [4]         IA5String,
		--same as http Content-Type header
		--examples:
		--   text/plain;charset=utf-8
		--   text/html;charset=utf-8
		--   image/gif

	content         [5]         OCTET STRING,
		--menu content of this menuLevel

	needUserInput1       [7]         BOOLEAN,
		--whether need user input, if TRUE, APP should display an input widget to user, then send user input content
		--in next menuReq or callSetup
	needUserInput2       [9]         BOOLEAN,
	needUserInput3       [11]        BOOLEAN,
		--extension of content and user input, in order to support multiple user input. eg. username ,passwd, verification code.

	nextAction   [15]     Mcc01NextAction,
		--if nextAction is menu, APP should send menuReq if user select this item
		--else if nextAction is call, APP should send callSetup if user select this item
		--else if nextAction is none, APP should send nothing if user select this item.

	newCalledNumber        [16]   IA5String OPTIONAL
		--must and only exist when nextAction==newSession
}

Mcc01CallSetup  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]   INTEGER,
		--callId may simply start from 1
	relaySN             [3]  INTEGER(0..4294967295),
		--gamt may use relaySN to do gass distrubtor

	pushTokenVoIP       [4]  IA5String,
		--used by gass to check whether APP happen in a call when a callin comming from relay

	auth                [5]  OCTET STRING (SIZE (16)) OPTIONAL,
		--authentication, only and must exist when sessionConfirm having nonce
		--auth = MD5(authcode+nonce)
		-- + means strcat(authcode, nonce)


	--calledNumber        [2]   IA5String,
		--address string, like "95510"

	--callingNumber       [3]   IA5String OPTIONAL,
	--callingName         [4]   OCTET STRING (SIZE (1..512)) OPTIONAL,

	--calledNumber, callingNumber, callingName no need to set since they already send to server in menuReq.


	menuLevel            [13]   IA5String OPTIONAL,
		--menuLevel which trigger voice call
	userInputContent1      [14]  OCTET STRING  OPTIONAL,
	userInputContent2      [15]  OCTET STRING  OPTIONAL,
	userInputContent3      [16]  OCTET STRING  OPTIONAL


	--Q: Why not exchange xIP/xPort in callSetup?
	--A: xIP/xPort may change when callAlerting or callAnswer since time from callSetup to callAlerting may be a relative
	--   long time due to callBusy.
	--
	--localIP             [21]   Mcc01IP,   
		--set to 0 if localIP not used
	--localPort           [22]   Mcc01Port,
	--stunIP             [23]   Mcc01IP,   
		--set to 0 if stunIP not set
		--server will get stunIP/stunPort from ip packet if stunIP not set
	--stunPort           [24]   Mcc01Port
}

Mcc01CallGeneral  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]     INTEGER,
	relaySN             [3]  INTEGER(0..4294967295)
		--relaySN should set to 0 in s -> c message to reduce message length

}

--Mcc01CallAlerting  ::= SEQUENCE
--{
--	sessionId              [1]   INTEGER,

--	callId              [11]     INTEGER,


	--localIP             [14]   Mcc01IP,   
		--IP for remote, set to 0 if localIP not used
	--localPort           [15]   Mcc01Port,

	--stun and turn is added by server
	--stunIP             [16]   Mcc01IP,   
		--IP for remote
	--stunPort           [17]   Mcc01Port,

	--turn ip/port is needed, we may distribute stream to different server to handle voice stream.
	--different turn ip/port is also used to distiguish different call for same relay 
	--turnIP             [18]   Mcc01IP,   
		--IP for remote
	--turnPort           [19]   Mcc01Port
--}

--Mcc01CallAnswer  ::= SEQUENCE
--{
--	sessionId              [1]   INTEGER,

--	callId              [11]     INTEGER,

	--we send same thing as CallAlerting, since remote may not receive CallAlerting
	--remote may ignore the following parms if CallAlerting have got already.
	--selectedAudioCodec   [13]  Mcc01AudioCodec OPTIONAL
		--MUST not set when supportedAudioCodecs not exist in callSetup

	--localIP             [14]   Mcc01IP,   
		--IP for remote, set to 0 if localIP not used
	--localPort           [15]   Mcc01Port,

	--stun and turn is added by server
	--stunIP             [16]   Mcc01IP,   
		--IP for remote
	--stunPort           [17]   Mcc01Port,

	--turn ip/port is needed, we may distribute stream to different server to handle voice stream.
	--different turn ip/port is also used to distiguish different call for same relay 
	--turnIP             [18]   Mcc01IP,   
		--IP for remote
	--turnPort           [19]   Mcc01Port
--}



Mcc01CallErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	busy(2),
	sessionIdInvalid(3),   --session may time out
	noSupportedAudioCodec(4),
	callIdInvalid(5),
	callAlreadyExist(6),  --callSetup got, while _call_id in session.h not 0
	messageInvalid(7),
	authFailed(8),
	parmInvalid(9),
	carrierOutOfService(10),
	--...
	otherError(99)
}       

Mcc01CallRelease  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]     INTEGER,
	relaySN             [3]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length

	errorCode           [13]  Mcc01CallErrorCode OPTIONAL
		--if call normal end, errorCode must not set.
}

Mcc01IP         ::= INTEGER(0..4294967295)    --network byte order
Mcc01Port       ::= INTEGER(0..65535)         --network byte order

--Mcc01AudioCodec ::= ENUMERATED 
--{   
--	opus8000Mono (0),
--	opus16000Mono(1)
--}       

--Mcc01AudioCodecs  ::= SEQUENCE SIZE (0..16) OF Mcc01AudioCodec

Mcc01CallSetAudioStreamReq  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]   INTEGER,
	relaySN             [3]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length


	localIP             [14]   Mcc01IP OPTIONAL,   
		--localIP not set if not use local ip
	localPort           [15]   Mcc01Port OPTIONAL,
	stunIP             [16]   Mcc01IP OPTIONAL,   
		--server will get stunIP/stunPort from ip packet if stunIP not set
	stunPort           [17]   Mcc01Port OPTIONAL,

		--turn is set by server
		--if req send from client, turnIP not set
	turnIP             [18]   Mcc01IP OPTIONAL,   
		--IP for remote
	turnPort           [19]   Mcc01Port OPTIONAL
}

Mcc01CallSetAudioStreamRsp  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]     INTEGER,
	relaySN             [3]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length



	localIP             [14]   Mcc01IP OPTIONAL,   
		--IP for remote
		--localIP not set if not use local ip
	localPort           [15]   Mcc01Port OPTIONAL,

	--stun and turn is added by server
	stunIP             [16]   Mcc01IP OPTIONAL,   
		--IP for remote
	stunPort           [17]   Mcc01Port OPTIONAL,

		--turn is set by server
		--if rsp send from client, turnIP not set
	--turn ip/port is needed, we may distribute stream to different server to handle voice stream.
	--different turn ip/port is also used to distiguish different call for same relay 
	turnIP             [18]   Mcc01IP OPTIONAL,   
		--IP for remote
	turnPort           [19]   Mcc01Port OPTIONAL
}

Mcc01CallSetAudioCodecReq  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]   INTEGER,
	relaySN             [3]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length


		--when a node want to raise sample rate to 16000, 
		--both supportOpus8000Mono and supportOpus16000Mono should set to true,
		--if supportOpus8000Mono not set to true and remote doesn't support 16000, no codec will match in rsp
	supportOpus8000Mono [12]  BOOLEAN,
	supportOpus16000Mono [13]  BOOLEAN
}

Mcc01CallSetAudioCodecRsp  ::= SEQUENCE
{
	sessionId              [1]   INTEGER,
	callId              [2]     INTEGER,
	relaySN             [3]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length


		--for node sending rsp, supportxxx = req.supportxxx && local-support
		--for node receiving rsp, call should be released if no codec supported in rsp.
	supportOpus8000Mono   [12]  BOOLEAN,
	supportOpus16000Mono   [13]  BOOLEAN
}

--Mcc01CallInAlerting  ::= SEQUENCE
--{
--	callId              [1]  INTEGER,
--	relaySN             [2]  INTEGER(0..4294967295)
--}

--Mcc01CallInReject  ::= SEQUENCE
--{
--	callId              [1]  INTEGER,
--	relaySN             [2]  INTEGER(0..4294967295)
--}

--Mcc01CallInReject  ::= SEQUENCE
--{
--	relaySN             [1]  INTEGER(0..4294967295),
--	uuid                [2]  IA5String,
		--uuid is from push notification
		--format: 550e8400-e29b-41d4-a716-446655440000
--	callingNumber       [3]  IA5String OPTIONAL
		--callingNumber is used in gass for traffic log
--}

--Mcc01CallInRejectAck  ::= SEQUENCE
--{
--	relaySN             [1]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length
--	uuid                [2]  IA5String
--}

--Mcc01CallInSetup  ::= SEQUENCE
--{
--	callId              [1]  INTEGER,
--	relaySN             [2]  INTEGER(0..4294967295),

--	calledNumber        [3]  IA5String,

--	callingNumber       [4]  IA5String OPTIONAL
--}

Mcc01CallInGeneral  ::= SEQUENCE
{
	callId              [1]  INTEGER,
	relaySN             [2]  INTEGER(0..4294967295)
		--relaySN should set to 0 in s -> c message to reduce message length
}

Mcc01CallInErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	busy(2),
	noSupportedAudioCodec(4),
	callIdInvalid(5),
	callAlreadyExist(6),  --callSetup got, while _call_id in session.h not 0
	messageInvalid(7),
	--...
	otherError(99)
}       

Mcc01CallInRelease  ::= SEQUENCE
{
	callId              [1]     INTEGER,
	relaySN             [2]  INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length
	errorCode           [13]  Mcc01CallInErrorCode OPTIONAL
		--if call normal end, errorCode must not set
}

Mcc01CallInSetAudioStreamReq  ::= SEQUENCE
{
	callId              [1]   INTEGER,
	relaySN             [2]   INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length

	localIP             [14]   Mcc01IP OPTIONAL,   
		--localIP not set if not use local ip
	localPort           [15]   Mcc01Port OPTIONAL,
	stunIP             [16]   Mcc01IP OPTIONAL,   
		--server will get stunIP/stunPort from ip packet if stunIP not set
	stunPort           [17]   Mcc01Port OPTIONAL,

		--turn is set by server
		--if req send from client, turnIP not set
	turnIP             [18]   Mcc01IP OPTIONAL,   
		--IP for remote
	turnPort           [19]   Mcc01Port OPTIONAL
}

Mcc01CallInSetAudioStreamRsp  ::= SEQUENCE
{
	callId              [1]     INTEGER,
	relaySN             [2]    INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length


	localIP             [14]   Mcc01IP OPTIONAL,   
		--IP for remote
		--localIP not set if not use local ip
	localPort           [15]   Mcc01Port OPTIONAL,

	--stun and turn is added by server
	stunIP             [16]   Mcc01IP OPTIONAL,   
		--IP for remote
	stunPort           [17]   Mcc01Port OPTIONAL,

		--turn is set by server
		--if rsp send from client, turnIP not set
	--turn ip/port is needed, we may distribute stream to different server to handle voice stream.
	--different turn ip/port is also used to distiguish different call for same relay 
	turnIP             [18]   Mcc01IP OPTIONAL,   
		--IP for remote
	turnPort           [19]   Mcc01Port OPTIONAL
}

Mcc01CallInSetAudioCodecReq  ::= SEQUENCE
{
	callId              [1]   INTEGER,
	relaySN             [2]   INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length

		--when a node want to raise sample rate to 16000, 
		--both supportOpus8000Mono and supportOpus16000Mono should set to true,
		--if supportOpus8000Mono not set to true and remote doesn't support 16000, no codec will match in rsp
	supportOpus8000Mono [12]  BOOLEAN,
	supportOpus16000Mono [13]  BOOLEAN
}

Mcc01CallInSetAudioCodecRsp  ::= SEQUENCE
{
	callId              [1]     INTEGER,
	relaySN             [2]     INTEGER(0..4294967295),
		--relaySN should set to 0 in s -> c message to reduce message length

		--for node sending rsp, supportxxx = req.supportxxx && local-support
		--for node receiving rsp, call should be released if no codec supported in rsp.
	supportOpus8000Mono   [12]  BOOLEAN,
	supportOpus16000Mono   [13]  BOOLEAN
}

Mcc01MessageNonceReq  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--messageId is a global parm, MUST be a random number to avoid messageId conflict, must >0
	relaySN             [2]  INTEGER(0..4294967295)
		--gamt may use relaySN to do gass distrubtor
}

Mcc01MessageNonceErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	otherError(99)
}       

Mcc01MessageNonceRsp  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--messageId is a global parm, MUST be a random number to avoid messageId conflict, must >0
	relaySN             [2]  INTEGER(0..4294967295),
		--relaySN should be set correctly since app may send multi messages one time. and app will be convenient to 
		--use relaySN to distiguish wich relay it send message to

	nonce               [3]  IA5String OPTIONAL,
		--only exist when message sending need authentication
		--valid in this message sending
		--only exist when no error code
		--nonce is 8 bytes size
	errorCode           [4]  Mcc01MessageNonceErrorCode OPTIONAL 
		--errorCode must not set when no error
}

Mcc01MessageSubmitReq  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--messageId is a global parm, MUST be a random number to avoid messageId conflict, must >0
	relaySN             [2]  INTEGER(0..4294967295),
		--gamt may use relaySN to do gass distrubtor

	auth                [3]  OCTET STRING (SIZE (16)) OPTIONAL,
		--authentication, only and must exist when messageNonceRsp having nonce
		--auth = MD5(authcode+nonce)

	calledNumber        [5]   IA5String,

	--callingNumber       [6]   IA5String,

	content            [7]   OCTET STRING
		--UTF-8 encoded
		--length of content cannot exceed 512 octets.

}

Mcc01MessageSubmitErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	authFailed(3),
	messageIdInvalid(5),
	otherError(99)
}       

Mcc01MessageSubmitRsp  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--same as messageSubmit
	relaySN             [2]   INTEGER(0..4294967295),
		--relaySN should be set correctly since app may send multi messages one time. and app will be convenient to 
		--use relaySN to distiguish wich relay it send message to

	errorCode           [4]  Mcc01MessageSubmitErrorCode OPTIONAL 
		--errorCode must not set when no error
}

Mcc01MessageInHello  ::= SEQUENCE
{
	seqId              [1]  INTEGER,
	relaySN            [2]  INTEGER(0..4294967295)
}

Mcc01MessageInHelloAck  ::= SEQUENCE
{
	seqId              [1]  INTEGER,
	relaySN            [2]  INTEGER(0..4294967295)
}

Mcc01MessageDeliverReq  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--messageId is a global parm, MUST be a random number to avoid messageId conflict, must >0
	relaySN             [2]   INTEGER(0..4294967295),

	--calledNumber        [5]   IA5String,

	callingNumber       [6]   IA5String,

	content            [7]   OCTET STRING,
		--UTF-8 encoded
		--length of content cannot exceed 512 octets.
	--timestamp          [8]  INTEGER
		--timestamp indicate the time calling number sending the message
		--the time since the Epoch (00:00:00 UTC, January 1, 1970), measured in seconds
		--NOT use INTEGER to avoid 2038 problem
	timestamp          [8]  IA5String
		--format: yyyyMMddHHmmssZ
		--for example: 20180205091435+0800

}

Mcc01MessageDeliverErrorCode ::= ENUMERATED 
{   
	noError(0),
	systemError (1),
	otherError(99)
}       

Mcc01MessageDeliverRsp  ::= SEQUENCE
{
	messageId           [1]   INTEGER,
		--same as messageDeliver
	relaySN             [2]   INTEGER(0..4294967295),

	errorCode           [4]  Mcc01MessageDeliverErrorCode OPTIONAL 
		--errorCode must not set when no error
}

END
